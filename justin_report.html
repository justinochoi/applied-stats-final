<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Justin Choi, Tengis Kelley, Heidi Tamm">

<title>NFL Win Projections: Bigger and Better</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="justin_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="justin_report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="justin_report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="justin_report_files/libs/quarto-html/popper.min.js"></script>
<script src="justin_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="justin_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="justin_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="justin_report_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="justin_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="justin_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="justin_report_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">NFL Win Projections: Bigger and Better</h1>
<p class="subtitle lead">December 4th, 2025</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Justin Choi, Tengis Kelley, Heidi Tamm </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   4.0.0     ✔ tibble    3.3.0
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.1.0     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: Matrix

Attaching package: 'Matrix'

The following objects are masked from 'package:tidyr':

    expand, pack, unpack</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>train <span class="ot">=</span> <span class="fu">readRDS</span>(<span class="st">"training_data.rds"</span>) </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> <span class="fu">readRDS</span>(<span class="st">"test_data.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<p>In the first project of the semester, we attempted to predict NFL win totals for each team using historical indicators of strength, such as previous point differential and strength of schedule. This approach yielded reasonable results, but there was much room for improvement. Notably, we failed to incorporate the actions teams take during a typical offseason to bolster their roster. In this updated version of that project, we focus on (1) <strong>free agent signings</strong> and (2) <strong>amateur draft picks</strong>. Both methods of acquiring players can dramatically elevate the outlook of teams. Marquee free agents are potentially worth multiple wins on their own, while amateur players, particularly those selected in the first round of the NFL draft, are superstars in the making.</p>
<p>We first discuss how we collected necessary data. We then show that knowing which free agents and amateur players a team signs during an offseason provides more accurate predictions about their next-season win total. We conclude with a summary of our findings and avenues for future research.</p>
</section>
<section id="data-collection" class="level1">
<h1>2. Data Collection</h1>
</section>
<section id="modeling" class="level1">
<h1>3. Modeling</h1>
</section>
<section id="baseline-model" class="level1">
<h1>3.1 Baseline Model</h1>
<p><span class="math display">\[
\begin{aligned}
W_i &amp;\sim \text{Binomial}(G_i, p_i) \\
\text{logit}(\mu_i) &amp;= \beta_0 + \beta_1 \cdot \text{PD_past_1}_i + u_{Tm[i]} \\
u_{\text{Tm}[i]} &amp;\sim \mathcal{N}(0, \sigma^2)
\end{aligned}
\]</span></p>
</section>
<section id="adding-new-information" class="level1">
<h1>3.2 Adding New Information</h1>
<p><span class="math display">\[
\begin{aligned}
W_i &amp;\sim \text{Binomial}(G_i, p_i) \\
\text{logit}(\mu_i) &amp;= \beta_0 + \beta_1 \cdot \text{PD_past_1}_i + \beta_2 \cdot \text{max_apy}_i
+ \beta_3 \cdot \text{pick}_i + \sum_{j=1}^{J} \beta_j \cdot \text{position}_{ij} + u_{Tm[i]} \\
u_{\text{Tm}[i]} &amp;\sim \mathcal{N}(0, \sigma^2) \\
\end{aligned}
\]</span></p>
</section>
<section id="bayesian-beta-binomial" class="level1">
<h1>3.3 Bayesian Beta-Binomial</h1>
<p><span class="math display">\[
\begin{aligned}
W_i &amp;\sim \text{Beta-Binomial}(G_i, p_i, \phi) \\
\text{logit}(\mu_i) &amp;= \beta_0 + \beta_1 \cdot \text{PD_past_1}_i + \beta_2 \cdot \text{max_apy}_i
+ \beta_3 \cdot \text{pick}_i + \sum_{j=1}^{J} \beta_j \cdot \text{position}_{ij} + u_{Tm[i]} \\
u_{\text{Tm}[i]} &amp;\sim \mathcal{N}(0, \sigma^2) \\
\phi &amp;\sim \text{Exponential}(0.1) \\
\beta_0 &amp;\sim \mathcal{N}(0, 0.25) \\
\beta_1 &amp;\sim \mathcal{N}(0, 4) \\
\sigma &amp;\sim \text{Exponential}(1)
\end{aligned}
\]</span></p>
</section>
<section id="gaussian-process-regression" class="level1">
<h1>3.4 Gaussian Process Regression</h1>
<p><span class="math display">\[
\begin{aligned}
W_i &amp;\sim \text{Binomial}(G_i, p_i), \\[4pt]
\text{logit}(p_i) &amp;= \beta_0 + g_{\text{Tm}_i}(\text{year}_t) + u_{\text{Tm}[i]}, \\[6pt]
\beta_0 &amp;\sim \mathcal{N}(0, 0.25), \\[6pt]
g_t(\cdot) &amp;\sim \text{GP}\!\left(0, \, k_t(\cdot,\cdot)\right), \\[6pt]
u_{\text{Tm}[i]} &amp;\sim \mathcal{N}(0, \sigma^2), \\[6pt]
\sigma &amp;\sim \text{Exponential}(1)
\end{aligned}
\]</span></p>
<p>Now it’s time to put our new data to the test. We will train models on NFL regular-season data from 2016-23, in an attempt to predict 2024 NFL regular-seasons wins for each team.</p>
<p>We wanted to start off my establishing a <strong>baseline</strong> model, a starting point from which we can improve on. We’ll use the model that returned the best predictions from our previous report: a simple binomial model with three terms: an intercept, the previous season’s point differential, and a team random effect. The model was specified using the lme4 R package:</p>
<p>A summary of the model is provided below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(baseline)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized linear mixed model fit by maximum likelihood (Laplace
  Approximation) [glmerMod]
 Family: binomial  ( logit )
Formula: cbind(W, L) ~ prior_PD + (1 | Tm)
   Data: train

      AIC       BIC    logLik -2*log(L)  df.resid 
   1289.6    1300.2    -641.8    1283.6       253 

Scaled residuals: 
     Min       1Q   Median       3Q      Max 
-2.91929 -0.96938 -0.00664  0.89125  2.92332 

Random effects:
 Groups Name        Variance Std.Dev.
 Tm     (Intercept) 0.0713   0.267   
Number of obs: 256, groups:  Tm, 32

Fixed effects:
             Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept) 0.0002108  0.0568173   0.004    0.997    
prior_PD    0.2392434  0.0389607   6.141 8.22e-10 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation of Fixed Effects:
         (Intr)
prior_PD -0.001</code></pre>
</div>
</div>
<p>The intercept term is 0, which makes sense - on a logit scale, this corresponds to a team with a .500 winning percentage. When a team allows as many points as it gains, we should expect it to be roughly average. Past year’s point differential has a significant effect on a team’s winning percentage: If a team had a large point differential in the past, it’s more likely to be successful in the future as well (and vice-versa).</p>
<p>But how well does the model do? It’s time to predict on unseen 2024 data and establish a baseline. For our error metric, we’ll use both Mean Absolute Error (MAE) and Root Mean Square Error (RMSE).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>base_prob <span class="ot">=</span> <span class="fu">predict</span>(baseline, test, <span class="at">type =</span> <span class="st">"response"</span>) </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>base_wins <span class="ot">=</span> <span class="dv">17</span> <span class="sc">*</span> base_prob </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">abs</span>(test<span class="sc">$</span>W <span class="sc">-</span> base_wins)) <span class="co"># 2.83 </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.829519</code></pre>
</div>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="fu">mean</span>((test<span class="sc">$</span>W <span class="sc">-</span> base_wins)<span class="sc">^</span><span class="dv">2</span>)) <span class="co"># 3.4 </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.396982</code></pre>
</div>
</div>
<p>The results are pretty decent - on average, we’re around 3 wins away from the true 2024 win totals. The RMSE is slightly higher than the MAE, in part because the 2024 NFL season seemed to feature a good number of unexpected outcomes (for example, the Washington Commanders going from a 4-13 record in 2023 to a 12-5 record in 2024).</p>
<p>Next, we’ll keep the same model structure, but add our free agent and draft-related covariates:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Generalized linear mixed model fit by maximum likelihood (Laplace
  Approximation) [glmerMod]
 Family: binomial  ( logit )
Formula: cbind(W, L) ~ max_apy + prior_PD + pick + category + (1 | Tm)
   Data: train

      AIC       BIC    logLik -2*log(L)  df.resid 
   1278.6    1321.1    -627.3    1254.6       244 

Scaled residuals: 
     Min       1Q   Median       3Q      Max 
-2.83912 -0.97637 -0.02712  0.93520  2.85782 

Random effects:
 Groups Name        Variance Std.Dev.
 Tm     (Intercept) 0.07728  0.278   
Number of obs: 256, groups:  Tm, 32

Fixed effects:
             Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept) -0.007624   0.089603  -0.085  0.93220    
max_apy      0.060916   0.036473   1.670  0.09489 .  
prior_PD     0.211733   0.045665   4.637 3.54e-06 ***
pick         0.026479   0.040094   0.660  0.50898    
categoryDL  -0.007004   0.105903  -0.066  0.94727    
categoryLB   0.185652   0.129768   1.431  0.15253    
categoryOL   0.040779   0.109117   0.374  0.70861    
categoryQB  -0.194678   0.131178  -1.484  0.13779    
categoryRB   0.562509   0.173091   3.250  0.00115 ** 
categoryTE  -0.246516   0.177511  -1.389  0.16491    
categoryWR  -0.069844   0.114115  -0.612  0.54050    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation of Fixed Effects:
           (Intr) max_py prr_PD pick   ctgrDL ctgrLB ctgrOL ctgrQB ctgrRB
max_apy     0.035                                                        
prior_PD   -0.029  0.160                                                 
pick       -0.048 -0.212 -0.445                                          
categoryDL -0.605 -0.084 -0.007  0.071                                   
categoryLB -0.493 -0.126 -0.039  0.020  0.431                            
categoryOL -0.573  0.064  0.076  0.001  0.476  0.384                     
categoryQB -0.491 -0.024  0.132  0.148  0.419  0.333  0.395              
categoryRB -0.365  0.016  0.009  0.007  0.304  0.255  0.305  0.245       
categoryTE -0.352  0.112 -0.004 -0.061  0.290  0.247  0.296  0.227  0.197
categoryWR -0.539  0.017  0.035 -0.025  0.451  0.356  0.454  0.356  0.278
           ctgrTE
max_apy          
prior_PD         
pick             
categoryDL       
categoryLB       
categoryOL       
categoryQB       
categoryRB       
categoryTE       
categoryWR  0.277</code></pre>
</div>
</div>
<p>As expected, big free agent contracts. corresponds to a greater win probability the following season. Prior point differential largely maintains its influence, while surprisingly, the draft pick number is almost completely uninformative. Also surprising is first-round running backs (categoryRB) giving their new teams a noticeable boost to their win totals, but other positions not contributing much. Before running the model, we expected the quarterback position to have a similar impact. Perhaps there are far more rookie quarterbacks who flame out than dominate the league a là Tom Brady or Patrick Mahomes.</p>
</section>
<section id="results" class="level1">
<h1>4. Results</h1>
</section>
<section id="model-summaries-and-diagnostics" class="level1">
<h1>4.1 Model Summaries and Diagnostics</h1>
</section>
<section id="predictive-capability" class="level1">
<h1>4.2 Predictive Capability</h1>
</section>
<section id="conclusion-limitations" class="level1">
<h1>5. Conclusion / Limitations</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>